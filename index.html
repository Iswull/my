<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #hint {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="hint">ÊãñÂä®Èù¢ÁâáÂà∞Ê°ÜÊû∂ÁöÑÂØπÂ∫î‰ΩçÁΩÆ</div>
    <!-- Ê∑ªÂä†GSAPÂíåThree.jsÂ∫ì -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js  "></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js  "></script>
    <script>
        let scene, camera, renderer, raycaster, mouse = new THREE.Vector2();
        let selectedFace = null, initialPosition = new THREE.Vector3();
        let faces = [], targetPositions = [];
        let completedFaces = 0;

        let initialEuler;
        let initialDistance;
        let targetPoint = new THREE.Vector3(0, 0, 0);
        let isRotating = false;


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); // ÊµÖÁÅ∞Ëâ≤ËÉåÊôØ
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Ê∑ªÂä†ÁéØÂ¢ÉÂÖâÂíåÊñπÂêëÂÖâ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // ÂàõÂª∫Á∫øÊ°ÜÈïøÊñπ‰Ωì
            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(3, 2, 4));
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x999999 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            scene.add(wireframe);

            // ÂàõÂª∫ÂèØ‰∫§‰∫íÈù¢Áâá
            const createFace = (width, height, color) => {
                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.75,
                    side: THREE.DoubleSide
                });
                return new THREE.Mesh(geometry, material);
            };

            // Èù¢ÁâáÂèÇÊï∞ËÆæÁΩÆÔºàÂØπÂ∫îÈù¢È¢úËâ≤Áõ∏ÂêåÔºåÈááÁî®Êõ¥È´òÁ∫ßÁöÑÈ¢úËâ≤ÊñπÊ°àÔºâ
            const faceParams = [
                { size: [3, 2], color: 0x88aaff, pos: [0, 0, 2], rot: new THREE.Euler(0, 0, 0) },    // Ââç
                { size: [3, 2], color: 0x88aaff, pos: [0, 0, -2], rot: new THREE.Euler(0, Math.PI, 0) },   // Âêé
                { size: [4, 2], color: 0x88aaff, pos: [-1.5, 0, 0], rot: new THREE.Euler(0, Math.PI/2, 0) }, // Â∑¶
                { size: [4, 2], color: 0x88aaff, pos: [1.5, 0, 0], rot: new THREE.Euler(0, -Math.PI/2, 0) },  // Âè≥
                { size: [3, 4], color: 0x88aaff, pos: [0, 1, 0], rot: new THREE.Euler(Math.PI/2, 0, 0) },    // ‰∏ä
                { size: [3, 4], color: 0x88aaff, pos: [0, -1, 0], rot: new THREE.Euler(-Math.PI/2, 0, 0) }    // ‰∏ã
            ];

            faceParams.forEach((param, index) => {
                const face = createFace(...param.size, param.color);
                
                if (index % 2 === 0) {
                    face.position.set(
                    (1 - 0.5) * 8,
                    5, // Á¶ªÂú∞È´òÂ∫¶
                    (index-2)  * 2
                ); 
                }
                else{
                // Èù¢ÁâáÂπ≥ÊîæÂú®Âú∞Èù¢ÔºåÈöèÊú∫Êï£ËêΩ
                    face.position.set(
                        (1 - 0.5) * 8,
                        0.5, // Á¶ªÂú∞È´òÂ∫¶
                        (index-2)  * 2
                );
                }
                
                // Èù¢ÁâáÂπ≥ÊîæÔºåËΩªÂæÆÈöèÊú∫ÊóãËΩ¨
                face.rotation.set(
                    0,
                    0.5 * Math.PI,
                    0
                );
                

                scene.add(face);
                faces.push({
                    mesh: face,
                    targetPos: new THREE.Vector3(...param.pos),
                    targetRot: param.rot.clone()
                });
            });

            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(faces.map(f => f.mesh));
            if (intersects.length > 0) {
                selectedFace = intersects[0].object;
                initialPosition.copy(selectedFace.position);
                selectedFace.material.opacity = 0.5; // ÈÄâ‰∏≠Êó∂Êõ¥ÈÄèÊòé
            }
            else {
        isRotating = true;
        initialMouseX = event.clientX;
        initialMouseY = event.clientY;
        initialEuler = camera.rotation.clone();
        initialDistance = camera.position.distanceTo(targetPoint);
    }
        }

        function onMouseMove(event) {
            //if (!selectedFace) return;
            if (selectedFace){

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.setFromCamera(mouse, camera);
            
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                selectedFace.position.copy(intersectPoint);
            }
        }
        else if (isRotating) {
        const deltaX = event.clientX - initialMouseX;
        const deltaY = event.clientY - initialMouseY;

        const sensitivity = 0.005; // ÊóãËΩ¨ÁÅµÊïèÂ∫¶ÔºàÂºßÂ∫¶/ÂÉèÁ¥†Ôºâ

        // ËÆ°ÁÆóËßíÂ∫¶ÂèòÂåñ
        const deltaPhi = -deltaX * sensitivity; // Êñπ‰ΩçËßíÂèòÂåñÔºàÁªïYËΩ¥Ôºâ
        const deltaTheta = deltaY * sensitivity; // ‰ª∞ËßíÂèòÂåñÔºàÁªïXËΩ¥Ôºâ

        // ÂàõÂª∫ËßíÂ∫¶ÂèòÂåñÁöÑÊ¨ßÊãâËßí
        const deltaEuler = new THREE.Euler(
            deltaTheta, // ÁªïXËΩ¥ÊóãËΩ¨
            deltaPhi,   // ÁªïYËΩ¥ÊóãËΩ¨
            0
        );

        // ËÆ°ÁÆóÊñ∞ÁöÑÊ¨ßÊãâËßí
        //const newEuler = initialEuler.clone().add(deltaEuler);
        const newEuler = new THREE.Euler(
    initialEuler.x + deltaEuler.x,
    initialEuler.y + deltaEuler.y,
    initialEuler.z + deltaEuler.z
);

        // ËÆ°ÁÆóÊñπÂêëÂêëÈáè
        const direction = new THREE.Vector3(0, 0, -1); // ÂàùÂßãÊñπÂêëÂêëÈáèÔºà-zËΩ¥Ôºâ
        direction.applyEuler(newEuler); // Â∫îÁî®ÊóãËΩ¨ÂêéÁöÑÊñπÂêë
        direction.normalize();
        direction.multiplyScalar(initialDistance); // Ê†πÊçÆÂàùÂßãË∑ùÁ¶ªÁº©Êîæ

        // ËÆ°ÁÆóÊñ∞‰ΩçÁΩÆÔºöÁõÆÊ†áÁÇπÂáèÂéªÊñπÂêëÂêëÈáèÔºàÂõ†‰∏∫ÊñπÂêëÊòØÊúùÂêëÁõÆÊ†áÁÇπÁöÑÔºâ
        const newPosition = targetPoint.clone().sub(direction);

        // Êõ¥Êñ∞Áõ∏Êú∫‰ΩçÁΩÆÂíåÊñπÂêë
        camera.position.copy(newPosition);
        camera.lookAt(targetPoint);
        camera.updateProjectionMatrix();
        // Êõ¥Êñ∞ÂàùÂßãÂèÇÊï∞
        initialEuler.add(deltaEuler);
        initialMouseX = event.clientX;
        initialMouseY = event.clientY;
    
        }
    }

        function onMouseUp() {
            isRotating = false;
            if (!selectedFace) return;

            selectedFace.material.opacity = 0.75; // ÊÅ¢Â§çÈÄèÊòéÂ∫¶
            
            let minDistance = Infinity;
            let targetIndex = -1;

            faces.forEach((face, index) => {
                if (face.mesh === selectedFace) {
                    const distance = selectedFace.position.distanceTo(face.targetPos);
                    if (distance < 2) {
                        targetIndex = index;
                    }
                }
            });

            if (targetIndex !== -1) {
                gsap.to(selectedFace.position, {
                    x: faces[targetIndex].targetPos.x,
                    y: faces[targetIndex].targetPos.y,
                    z: faces[targetIndex].targetPos.z,
                    duration: 0.5,
                    ease: "power3.out"
                });

                gsap.to(selectedFace.rotation, {
                    x: faces[targetIndex].targetRot.x,
                    y: faces[targetIndex].targetRot.y,
                    z: faces[targetIndex].targetRot.z,
                    duration: 0.8,
                    ease: "elastic.out(1, 0.3)",
                    onComplete: () => {
                        completedFaces++;
                        if (completedFaces === 6) {
                            document.getElementById('hint').textContent = "üéâ ÈïøÊñπ‰ΩìÊûÑÂª∫ÂÆåÊàêÔºÅ";
                        }
                    }
                });

                faces = faces.filter((_, i) => i !== targetIndex);
            } else {
                gsap.to(selectedFace.position, {
                    x: initialPosition.x,
                    y: initialPosition.y,
                    z: initialPosition.z,
                    duration: 1,
                    ease: "bounce.out"
                });
            }

            selectedFace = null;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html> 
